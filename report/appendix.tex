\subsection{Optimization examples}
\label{subsec:optim}
\begin{figure}[H]
\begin{subfigure}{.48\textwidth}
  \begin{lstlisting}
    int main() {
      int a = 0;
      int b = a + 2;
      return a;
    }
  \end{lstlisting}
  \caption{Source}
  \label{fig:cpbefore}
\end{subfigure}
\begin{subfigure}{.48\textwidth}
  \begin{lstlisting}
    int main() {
      int a = 0;
      int b = 0 + 2;
      return 0;
    }    
  \end{lstlisting}
  \caption{Target}
  \label{fig:cpafter}
\end{subfigure}
\caption{Example of Constant Propagation}
\label{fig:cpexamples}
\end{figure}
\begin{figure}[H]
\begin{subfigure}{.48\textwidth}
  \begin{lstlisting}
    int main() {
      int a = 0;
      int b = 0 + 2;
      return 0;
    }
  \end{lstlisting}
  \caption{Source}
  \label{fig:daebefore}
\end{subfigure}
\begin{subfigure}{.48\textwidth}
  \begin{lstlisting}
    int main() {
      return 0;
    }    
  \end{lstlisting}
  \caption{Target}
  \label{fig:daeafter}
\end{subfigure}
\caption{Example of Dead Allocation Elimination}
\label{fig:daeexamples}
\end{figure}
\begin{figure}[H]
\begin{subfigure}{.48\textwidth}
  \begin{lstlisting}
    int main() {
      int a = 0;
      int * p;
      *p = 1;
      a = *p;
      return 0;
    }
  \end{lstlisting}
  \caption{Source}
  \label{fig:dlsebefore}
\end{subfigure}
\begin{subfigure}{.48\textwidth}
  \begin{lstlisting}
    int main() {
      int a = 0;
      int * p;
      return 0;
    }
  \end{lstlisting}
  \caption{Target}
  \label{fig:dlseafter}
\end{subfigure}
\caption{Example of Dead Store and Load Elimination}
\label{fig:dlseexamples}
\end{figure}
\begin{figure}[H]
\begin{subfigure}{.48\textwidth}
  \begin{lstlisting}
    foo(ptr p) {
      var ptr q, int a;
      q = malloc(1);
      *q = 123;
      bar(p);
      a = *q;
      *p = a;
    }
  \end{lstlisting}
  \caption{Source}
  \label{fig:multiplebefore}
\end{subfigure}
\begin{subfigure}{.48\textwidth}
  \begin{lstlisting}
    foo(ptr p) {

                //DAE
                //DSE
      bar(p);
                //DLE
      *p = 123; //CP
    }
  \end{lstlisting}
  \caption{Target}
  \label{fig:multipleafter}
\end{subfigure}
\caption{Example with multiple optimizations, taken from~\cite{DBLP:conf/pldi/KangHMGZV15}}
\label{fig:multipleexamples}
\end{figure}

\subsection{Memory implementation}
The new definition of the memory is the following:

\begin{lstlisting}[basicstyle=\footnotesize]
Record mem' : Type := mkmem {
mem_contents: PMap.t (ZMap.t memval);  (**r [block -> offset -> memval] *)
mem_access: PMap.t (Z -> perm_kind -> option permission);
(**r [block -> offset -> kind -> option permission] *)
mem_concrete: PMap.t (option Z); (** [block -> option Z] **)
mem_offset_bounds : PMap.t (Z*Z); (** [block -> Z * Z ] **)
nextblock: block;
access_max:
  forall b ofs, perm_order'' (mem_access#b ofs Max) (mem_access#b ofs Cur);
nextblock_noaccess:
  forall b ofs k, ~(Plt b nextblock) -> mem_access#b ofs k = None;
contents_default:
  forall b, fst mem_contents#b = Undef;
nextblocks_logical:
  forall b, ~(Plt b nextblock) -> mem_concrete#b = None;
addresses_in_range:
  forall bo addr (IN_BLOCK: addr_in_block mem_concrete mem_offset_bounds
      mem_access addr bo),
    in_range addr (1,max_address);
no_concrete_overlap:
  forall addr, uniqueness (addr_in_block mem_concrete mem_offset_bounds
      mem_access addr);
}.
\end{lstlisting}

\subsection{Memory injection}
The new definition of memory injection is the following:

\begin{lstlisting}[basicstyle=\footnotesize]
Record inject' (f: meminj) (m1 m2: mem) : Prop :=
mk_inject {
  mi_inj:
    mem_inj f m1 m2;
  mi_freeblocks:
    forall b, ~(valid_block m1 b) -> f b = None;
  mi_mappedblocks:
    forall b b' delta, f b = Some(b', delta) -> valid_block m2 b';
  mi_no_overlap:
    meminj_no_overlap f m1;
  mi_representable:
    forall b b' delta ofs,
    f b = Some(b', delta) ->
    perm m1 b (Ptrofs.unsigned ofs) Max Nonempty \/
      perm m1 b (Ptrofs.unsigned ofs - 1) Max Nonempty ->
    delta >= 0 /\ 0 <= Ptrofs.unsigned ofs + delta <= Ptrofs.max_unsigned;
  mi_perm_inv:
    forall b1 ofs b2 delta k p,
    f b1 = Some(b2, delta) ->
    perm m2 b2 (ofs + delta) k p ->
    perm m1 b1 ofs k p \/ ~perm m1 b1 ofs Max Nonempty
}.
\end{lstlisting}
