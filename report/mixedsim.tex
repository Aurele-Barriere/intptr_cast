\def\backwardforward{
  \begin{figure}
  \begin{subfigure}{.48\textwidth}
    \centering
    \begin{tikzpicture}[%
        every node/.style={circle,minimum size=3pt,minimum height=3pt, inner sep=0pt},
        shorten >=2pt,
        node distance=1.5cm, >=latex
      ]
      \node [draw] (0) [color=blue, fill] {};
      \node [draw] (1) [color=blue, fill, below left=of 0] {};
      \node [draw] (2) [color=blue, fill, below=of 0] {};
      \node [draw] (3) [color=blue, fill, below right=of 0] {};
      \node [draw] (4) [color=blue, fill, below left=of 2] {};
      \node [draw] (5) [color=blue, fill, below=of 2] {};
      \node [draw] (6) [color=blue, fill, below=of 3] {};
      \node [draw] (7) [color=red, fill, right=of 0, xshift=1.5cm] {};
      \node [draw] (8) [color=red, fill, below left=of 7] {};
      \node [draw] (9) [color=red, fill, below=of 7] {};
      \node [draw] (10) [color=red, fill, below=of 8] {};
      \node [draw] (11) [color=red, fill, below=of 9] {};
      \node (src) [above=of 0, yshift=-1cm] {\color{blue}Source};
      \node (tgt) [above=of 7, yshift=-1cm] {\color{red}Target};
      \path [draw] (0) edge[->]  node {} (1)
      (0) edge[->]  node {} (2)
      (0) edge[->]  node {} (3)
      (2) edge[->]  node {} (4)
      (2) edge[->]  node {} (5)
      (3) edge[->]  node {} (6)
      (7) edge[->]  node {} (8)
      (7) edge[->]  node {} (9)
      (8) edge[->]  node {} (10)
      (9) edge[->]  node {} (11);
      \draw[dashed] (0) -- (7);
      \draw[dashed] (3) -- (8);
      \draw[dashed] (2) -- (9);
      \draw[dashed] (5) -- (11);
      \draw[dashed] (6) -- (10);
    \end{tikzpicture}
    \caption{Example of backward simulation}
    \label{fig:backward}
    \end{subfigure}
  \begin{subfigure}{.48\textwidth}
    \centering
    \begin{tikzpicture}[%
        every node/.style={rectangle,minimum size=3pt,minimum height=3pt, inner sep=0pt},
        shorten >=2pt,
        node distance=1.5cm, >=latex
      ]
      \node [draw] (0) [color=red, fill] {};
      \node [draw] (1) [color=red, fill, below right=of 0] {};
      \node [draw] (2) [color=red, fill, below=of 0] {};
      \node [draw] (3) [color=red, fill, below left=of 0] {};
      \node [draw] (4) [color=red, fill, below right=of 2] {};
      \node [draw] (5) [color=red, fill, below=of 2] {};
      \node [draw] (6) [color=red, fill, below=of 3] {};
      \node [draw] (7) [color=blue, fill, left=of 0, xshift=-1.5cm] {};
      \node [draw] (8) [color=blue, fill, below right=of 7] {};
      \node [draw] (9) [color=blue, fill, below=of 7] {};
      \node [draw] (10) [color=blue, fill, below=of 8] {};
      \node [draw] (11) [color=blue, fill, below=of 9] {};
      \node (src) [above=of 7, yshift=-0.5cm] {\color{blue}Source};
      \node (tgt) [above=of 0, yshift=-0.5cm] {\color{red}Target};
      \path [draw] (0) edge[->]  node {} (1)
      (0) edge[->]  node {} (2)
      (0) edge[->]  node {} (3)
      (2) edge[->]  node {} (4)
      (2) edge[->]  node {} (5)
      (3) edge[->]  node {} (6)
      (7) edge[->]  node {} (8)
      (7) edge[->]  node {} (9)
      (8) edge[->]  node {} (10)
      (9) edge[->]  node {} (11);
      \draw[dashed] (0) -- (7);
      \draw[dashed] (3) -- (8);
      \draw[dashed] (2) -- (9);
      \draw[dashed] (5) -- (11);
      \draw[dashed] (6) -- (10);
    \end{tikzpicture}
    \caption{Example of forward simulation}
    \label{fig:forward}
    \end{subfigure}
    \caption{Examples of simulations}
  \end{figure}
}

\def\mixed{
  \begin{figure}
    \centering
    \begin{tikzpicture}[%
        every node/.style={rectangle,minimum size=4pt,minimum height=4pt, inner sep=0pt},
        shorten >=2pt,
        node distance=1.3cm, >=latex
      ]
      \node [draw] (0) [color=blue, fill] {};
      \node [draw] (1) [circle, color=blue, fill, below=of 0] {};
      \node [draw] (2) [color=blue, fill, below left=of 1] {};
      \node [draw] (3) [color=blue, fill, below=of 1] {};
      \node [draw] (4) [color=blue, fill, below=of 3] {};
      \node [draw] (5) [color=red, fill, right=of 0] {};
      \node [draw] (6) [circle, color=red, fill, below=of 5] {};
      \node [draw] (7) [circle, color=red, fill, below right=of 5] {};
      \node [draw] (8) [color=red, fill, below=of 6] {};
      \node [draw] (9) [color=red, fill, below=of 8] {};
      \node [draw] (10) [color=red, fill, below right=of 8] {};
      \node (src) [left=of 0] {\color{blue}Source};
      \node (tgt) [right=of 5] {\color{red}Target};
 
      \path [draw] (0) edge[->]  node {} (1)
      (1) edge[->]  node {} (2)
      (1) edge[->]  node {} (3)
      (3) edge[->]  node {} (4)
      (5) edge[->]  node {} (6)
      (5) edge[->]  node {} (7)
      (6) edge[->]  node {} (8)
      (8) edge[->]  node {} (9)
      (8) edge[->]  node {} (10);
      \draw[dashed] (0) -- (5);
      \draw[dashed] (1) -- (6);
      \draw[dashed] (3) -- (8);
      \draw[dashed] (4) -- (9);
    \end{tikzpicture}
    \caption{Example of mixed simulation}
    \label{fig:mixed}
  \end{figure}
}

\def\at#1{$\mathit{atomic}($#1$)$}

\def\oldproof{
    \begin{tikzpicture}[%
        every node/.style={rectangle, font=\small},
        shorten >=2pt,
        node distance=2cm
      ]
      \node (cc) {CompCert C};
      \node (cstrat) [right=of cc] {CStrategy};
      \node (clight) [right=of cstrat] {Clight};
      \node (dots) [right=of clight] {\dots\vphantom{C}};
      \node (mach) [right=of dots] {Mach};
      \node (asm) [right=of mach] {ASM};
      \node (atcstrat) [below=of cstrat] {\at{CStrategy}};
      \path [draw] (cc) edge[<-, above,line width=1pt] node {1. backward} (cstrat);
      \path [draw] (cstrat) edge[->, above,line width=1pt] node {1. forward} (clight);
      \path [draw] (clight) edge[->, above,line width=1pt] node {1. forward} (dots);
      \path [draw] (dots) edge[->, above,line width=1pt] node {1. forward} (mach);
      \path [draw] (mach) edge[->, above,line width=1pt] node {1. forward} (asm);
      \path [draw] (cstrat) edge[->, bend left=20, above,line width=1pt] node {2. forward} (asm);
      \path [draw] (atcstrat) edge[->, above left,line width=1pt] node {3. forward} (asm);
      \path [draw] (cc) edge[<-, bend right=20, above right,line width=1pt] node {4. backward} (atcstrat);
      \path [draw] (atcstrat) edge[<-, bend right=20, above left,line width=1pt] node {4. backward} (asm);
      \path [draw] (cc) edge[<-, bend right=70, below,line width=1pt] node {5. backward} (asm);
    \end{tikzpicture}
}

\def\mixedproof{
    \begin{tikzpicture}[%
        every node/.style={rectangle, font=\small},
        shorten >=2pt,
        node distance=2cm
      ]
      \node (cc) [] {CompCert C};
      \node (cstrat) [right=of cc] {CStrategy};
      \node (clight) [right=of cstrat] {Clight};
      \node (dots) [right=of clight] {\dots\vphantom{C}};
      \node (mach) [right=of dots] {Mach};
      \node (asm) [right=of mach] {ASM};
      \node (atcstrat) [below=of cstrat] {\at{CStrategy}};
      \node (atclight) [below=of clight] {\at{Clight}};
      \node (atdots) [below=of dots] {\at{\dots}};
      \node (atmach) [below=of mach] {\at{Mach}};
      \path [draw] (cc) edge[<-, above,line width=1pt] node {1. backward} (cstrat);
      \path [draw] (cstrat) edge[<->, above,line width=1pt] node {1. mixed} (clight);
      \path [draw] (clight) edge[<->, above,line width=1pt] node {1. mixed} (dots);
      \path [draw] (dots) edge[<->, above,line width=1pt] node {1. mixed} (mach);
      \path [draw] (mach) edge[<->, above,line width=1pt] node {1. mixed} (asm);
      \path [draw] (atcstrat) edge[<-,below right,line width=1pt] node {2. backward} (clight);
      \path [draw] (atclight) edge[<-,below right,line width=1pt] node {2. backward} (dots);
      \path [draw] (atdots) edge[<-,below right,line width=1pt] node {2. backward} (mach);
      \path [draw] (atmach) edge[<-,above left,line width=1pt] node {2. backward} (asm);
      \path [draw] (cc) edge[<-,above right,line width=1pt] node {3. backward} (atcstrat);
      \path [draw] (atcstrat.300) edge[<-, bend right=90, below,line width=1pt] node {3. backward} (atclight);
      \path [draw] (atclight.300) edge[<-, bend right=90, below,line width=1pt] node {3. backward} (atdots);
      \path [draw] (atdots.300) edge[<-, bend right = 90, below,line width=1pt] node {3. backward} (atmach);
      \path [draw] (cc) edge[<-, bend right=90, below,line width=1pt] node {4. backward} (asm);
    \end{tikzpicture}
}

\label{sec:mixedsim}
In the quasi-concrete memory model, with the addition of the \textit{capture} function, every language of CompCert is now non-deterministic. Indeed, giving a concrete address to a logical block is a non-deterministic operation, whereas the logical allocation used so far in CompCert was deterministic.

\subsection{Simulations in CompCert and properties}
To prove the correctness of CompCert, one must prove that the behavior of the generated target code is one of the behaviors of the original source code. 
To do so, CompCert uses \textit{backward simulations} between the semantics of the source code and the generated code.
In CompCert, the semantics of each language is defined. The semantics of a program is a set of states (with initial and final states) and a relation between states meaning that one can go from one state to another with a given observable trace.

\subsubsection{Definition: Semantics of a program p}: $\mathit{Sem}(p) = (\states{p},I_p,F_p,\step{p})$ where $\step{p}\subseteq\statesÂ {p}\times\traces\times\states{p}$ and $I,F\subseteq\states{p}$. $t\in\traces$ is a trace, \textit{i.e.} a list of observable events (system call, store or load).

A straightforward way to show that two programs $p_s$ and $p_t$ are semantically equivalent could be to show that their semantics are \textit{bisimulated}, meaning that there exists a relation between states of the source and target semantics such that every time the source program takes a step to a new state, the target program takes a step with the same trace to a matching state, and vice versa. However, such a relation is in general too strong, as it does not allow basic optimizations.

A backward simulation is a weaker simulation that proves semantics preservation while still allowing optimizations.

\subsubsection{Definition: Backward Simulation} Let $sp$ a source program and $tp$ a target program. A backward simulation is a relation $R$ such that
\begin{itemize}
\item $\forall i\in I_{tp}, \exists i'\in I_{sp}, (i,i')\in R$
\item $\forall t\in\traces, ss_1\in\states{sp},st_1,st_2\in\states{tp},$\\
      $\quad(ss_1,st_1)\in R~\wedge~(st_1,t,st_2)\in\step{tp}\implies$\\
      $\exists ss_2\in\states{sp}, (ss_1,t,ss_2)\in\step{sp}$
\end{itemize}
Informally, each time the target program takes a step to a new state, the source program also takes a step to a matching state. This is enough to claim that the target's behavior is a refinement of the source's behavior. An example can be seen Figure~\ref{fig:backward}. The relation is described with the dashed lines. We can see that every target behavior matches a source behavior.

\subsubsection{Forward Simulations} One can similarly define a forward simulation in a symmetric way: each time the source program takes a step to a new state, the target program also takes a step to a matching state. This means that the target's behavior extends the source's behavior. An example can be seen Figure~\ref{fig:forward}.

\backwardforward

\subsubsection{Theorem: forward to backward} If the target language is \textit{determinate} (a weaker version of determinism) and the source language is \textit{receptive} and there is a forward simulation between the semantics of $sp$ and $tp$, then we can construct a backward simulation between the semantics of $sp$ and $tp$. Informally, if the target language is determinate, then for a given trace, there can be only one target step. However, with the source language being receptive, there will exist one matching step for any possible trace. We can then deduce that any target step is matched with a corresponding source step.

\subsubsection{Theorems: simulation composition} Let $S_1,S_2,S_3$ be semantics.
If there is a forward simulation between $S_1$ and $S_2$, and between $S_2$ and $S_3$, then there is a forward simulation between $S_1$ and $S_3$.
If there is a backward simulation between $S_1$ and $S_2$, and between $S_2$ and $S_3$, then there is a backward simulation between $S_1$ and $S_3$.

\subsection{Atomic Semantics and properties}
\subsubsection{Definition: Atomic Semantics} $\mathit{Atomic}(\states{p},I_p,F_p,\step{p}) = (\traces\times\states{p},\{[]\}\times I_p,\{[]\}\times F_p,\atstep{p})$ where $[]$ is the empty trace and $\atstep{p}$ is defined as follow:
\begin{itemize}
\item $(s_1,[],s_2)\in\step{p}\implies(([],s_1),[],([],s_2))\in\atstep{p}$
\item $(s_1,ev::t,s_2)\in\step{p}\implies(([],s_1),[ev],(t,s_2))\in\atstep{p}$
\item $((ev::t,s),[ev],(t,s))\in\atstep{p}$
\end{itemize}
Informally, $\mathit{Atomic}$ of a semantics is the same semantics where steps with multiple events traces have been replaced with several single-event steps.

\subsubsection{Theorem: Factor backward simulation} If there is a backward simulation between $S_1$ and $S_2$ and $S_1$ has \textit{single events}, then there is a backward simulation between $S_1$ and $\mathit{Atomic}(S_2)$.

\subsection{Non-determinism}
To prove the correctness of the compilation, we need to prove that for every source C program $sp$, if $tp$ is the compiled ASM program, then we have a backward simulation between $\mathit{Sem}(sp)$ and $\mathit{Sem}(tp)$.

Previously, in CompCert, the proof of correctness used forward simulations for almost every pass, then used the forward to backward simulation theorem to deduce a backward simulation between CompCertC and ASM. More details on this proof can be found in Appendix, section~\ref{subsec:oldproof}.

However, in the quasi-concrete model, the intermediate and target languages of CompCert are no longer \textit{determinate}. Indeed, the \textit{capture} function can give any address to a logical block, as long as it doesn't overlap with other blocks.
Thus, the use of forward simulations is no longer relevant.

\subsection{Mixed simulations and properties}
To prove the correctness of CompCert with the new memory model, we introduce \textit{mixed simulations}. Informally, at each state of the semantics, either we have a local forward simulation, or a local backward simulation. For most steps, we use forward reasoning (and it can be proved by adapting the previous forward simulation proof that used to be in CompCert), but for external calls (such as \textit{capture} and other unknown functions that might capture blocks), we use a backward reasoning. This is illustrated Figure~\ref{fig:mixed}, with round states being the states where an external function or a builtin function is called (these states are called \textit{external states}). Because the capture function is the only non-deterministic function of CompCert C, builtin functions and unknown external functions are the only place where non-deterministic behavior can occur.

\subsubsection{Definition: Mixed Simulation} Let $sp$ a source program and $tp$ a target program. A mixed simulation is a relation $R$ such that
\begin{itemize}
\item $\forall i\in I_{tp}, \exists i'\in I_{sp}, (i,i')\in R$
\item $\forall t\in\traces, ss_1\in\states{sp},st_1\in\states{tp},\quad(ss_1,st_1)\in R\implies ($\\
      $\textbf{Forward: }\wedge\forall ss_2, (ss_1,t,ss_2)\in\step{sp}\implies\exists st_2, (st_1,t,st_2)\in\step{tp}  \quad\vee$\\
      $\textbf{Backward: }\forall st_2, (st_1,t,st_2)\in\step{tp}\implies\exists ss_2, (ss_1,t,ss_2)\in\step{sp} \quad)$
\item Every state where forward reasoning is applied should have \textit{local determinacy}
\end{itemize}

\mixed

\subsubsection{Theorem: Mixed to Backward simulation}
If there is a mixed simulation between $S_1$ and $S_2$, then there is a backward simulation between $\mathit{Atomic}(S_1)$ and $S_2$.

To prove it, we use the local determinacy and local receptivity of states with forward reasoning, in a similar way to the Forward to Backward simulation theorem. This theorem also requires several hypothesis on the source and target languages (\texttt{single\_events}, \texttt{well\_behaved}) that we proved for each mixed simulation used in the correctness proof.

\subsection{The new correctness proof}
\begin{enumerate}
\item Prove a mixed simulation for each pass between CStrategy and ASM. We can use the previous forward simulation proof for every non-external states. The backward simulation between CompCert C and CStrategy is unchanged.
\item We use the mixed to backward simulation theorem on every mixed simulation.
\item We use the factor backward simulation theorem on every backward simulation.
\item We use the composition of backward simulations to deduce a backward simulation between CompCert C and ASM.
\end{enumerate}

The proof is illustrated Figure~\ref{fig:mixedproof}.

\begin{figure}
  \makebox[\textwidth][c]{\mixedproof}
  \caption{The new correctness proof}
  \label{fig:mixedproof}
\end{figure}
