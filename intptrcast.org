* DONE [INTPTR] meeting about the paper (14h)
  SCHEDULED: <2017-05-17 Wed>
* DONE [INTPTR] meeting 11h
  SCHEDULED: <2017-05-18 Thu>
* TODO [INTPTR][memupdate] semantics update on memory
  DEADLINE: <2017-06-01 Thu>
  in [[/home/aurele/intptrcast/CompCert-intptr/common/Memory.v][Memory.v]]
** DONE [INTPTR][memupdate] add p:option Z
   called mem_concrete inside the memory

   Remaining question:
   Should a call of free set the option back to None or leave it unchanged?
   It depends on the semantics we want to give to the casting of a freed pointer.
    -> the current decision is to leave it unchanged
   
** DONE [INTPTR][memupdate][consistency] add consistency

   added as a Definition: mem -> Prop

*** DONE [INTPTR][memupdate][consistency] No overlap

    I've implemented the simple version of overlap (we don't look inside the blocks the free addresses)

    To define this we need the size of each block.
    This has been added inside the memory as a field mem_block_size : block -> Z.

    
    Two questions on the size field:
    
        What should be the initial value of the size? on an empty memory. -> doesn't really matter
    
	When freeing, should we put it back to 0? -> NO

*** DONE [INTPTR][memupdate][consistency] Next block logicals
    
    This says that every block after nextblock is a logical block.
    Because we never want to capture a block that hasn't been allocated.
    This is need to prove memory_consistency, so it has been added here.

*** DONE [INTPTR][memupdate][consistency] First and last address
    
    For now, we only have a property that says that there is no concrete block
    with concrete address 0.
    How to deal with last address? At this point, the memory is infinite. 

    Should it be done in a later pass of CompCert? Or right now because we are dealing with real addresses?
    
*** DONE [INTPTR][memupdate][consistency] contained in memory

    We want to say that no block overflows the memory, i.e
    forall b, address(b)+size(b) < max_memory.
    Here again, we need the size of the memory.

    Both of these properties using the max size make memory_consistency preservation hard to prove.
    
** DONE [INTPTR][memupdate] Proof of memory consistency

   I have proved that empty is a consistent memory.

   And for every operation in {store,storebytes,alloc,free,perm_drop,capture},
   I have proved memory_consistency preservation.

** DONE [INTPTR][memupdate] add realize/capture as a fifth operation

   Capture should now be an operation, just like store,alloc,...
   This has been implemented with a predicate rather than a function,
   Because the address given to a block while capturing is undeterministic.
   
   Questions:

       When trying to capture an already concrete block, is this a capture? -> Yes, this sould be allowed
       Maybe sometimes, we'll have to successives capture of the same pointer.

       One of the hypothesis of the predicate is the memory_consistency preservation. Is that right?

** DONE [INTPTR][memupdate] add properties of capture

   Each operation has a lot of theorems. Some might be useful later.
   What should we prove for the capture ?
   DONE : memory_consistency preservation

   We'll see later.

** DONE [INTPTR][memupdate] add valid pointer
   
   See page 6, section 4 of the paper.

** DONE [INTPTR][memupdate] remove mem_valid
** DONE [INTPTR][memupdate] rewrite valid_pointer
** DONE [INTPTR][memupdate] remove size, remember low and high offsets
   implemented with a field 
   mem_offset_bounds
   block -> Z*Z
** DONE [INTPTR][memupdate] rewrite overlap
** DONE [INTPTR][memupdate] rewrite consistency proofs
   
   Need proofs for alloc
   
   And issue:
   I have zle lo addr, I want to prove lo<=addr.
   However, zle is {x<=y}+{y>x}. -> DONE
   
** DONE [INTPTR][memupdate] rewrite normalize and denormalize

   With the new block representation (p,lo,hi)

** DONE [INTPTR][memupdate] add memory parameter
   I use [if Archi.ptr64 then int64 else int].
   Is it ok?
   It seems that [Archi.ptr64] is set to false, will it be changed when compiling for x64?

   Representing the addresses:
   Either we use the types int and int64, and then for each operation,
   we must prove they are in the right range.
   Issues arise because we often add an address and something else (for instance, low offset bound)

   Or we use type Z, and then we add a memory consistency invariant,
   that says that every concrete address is in the right range.
   But then we must cast the address from Z to int. Is it ok?

** DONE [INTPTR][memupdate] finish consistency proofs
** DONE [INTPTR][memupdate][review] pull request
*** DONE [INTPTR][memupdate][review] put consistency inside of mem'
*** DONE [INTPTR][memupdate][review] do every obligation
*** DONE [INTPTR][memupdate][review] memory size?
    
    changed it to max_address for now
    the issue of real memory size should be addressed later
*** DONE [INTPTR][memupdate][review] no let
*** DONE [INTPTR][memupdate][review] inductive addr_in_concrete_block. inductive consistency
*** DONE [INTPTR][memupdate][review] name hypothesis in weaker_access
*** DONE [INTPTR][memupdate][review] remove comment in empty
*** DONE [INTPTR][memupdate][review] change exists_at_most_one_block
*** DONE [INTPTR][memupdate][review] spaces
*** DONE [INTPTR][memupdate][review] HRANGE instead of HLOW HHIGH
*** DONE [INTPTR][memupdate][review] remove exists_at_most_one_block
*** DONE [INTPTR][memupdate][review] addresses_in_range should rely on hi lo rather than address_in_block
    We'll do it later, if we change our minds regarding the way permissions are given

*** DONE [INTPTR][memupdate][review] rename weaker_access (access_le?)
*** DONE [INTPTR][memupdate][review] concrete_nextblock needs to be changed
*** DONE [INTPTR][memupdate][review] double capture
*** DONE [INTPTR][memupdate][review] return offset in addr_in_concrete_block
*** DONE [INTPTR][memupdate][review] predicate for addr in [p+lo, p+hi[
*** DONE [INTPTR][memupdate][review] rename m_access
*** DONE [INTPTR][memupdate][review] use uniqueness for exists_at_most_one
*** DONE [INTPTR][memupdate][review] change addr_in_block for a pair
*** DONE [INTPTR][memupdate][review] define range
** DONE [INTPTR][memupdate] rewrite with better coq style (no arrows)
   
   omit forall
   name hypothesis
   name goal with << >>
   props in caps
   a.(x)
   exploit

   using Sflib library

** TODO [INTPTR][memupdate] add normalization of pointer (cast2int) and denormalization (cast2ptr)

   see page 6, section 4 of the paper.
   The denormalize is a predicate, not a function.
   Because I can't filter a Map on the Positive numbers.

   Is it ok?

** TODO [INTPTR][memupdate] null pointer
   Add it (page 6).
   Raises undef when storing or loading null pointer.

   Should we add it as a block and change the definitions of the operations?
   
** DONE [INTPTR][memupdate] use Nonempty instead of Readable
** TODO [INTPTR][meminj] Definition of max_address
   This might just be Ptrofs.max_unsigned   

* TODO [INTPTR][meminj] Memory Injection
** DONE [INTPTR][meminj] change memory extension

   We need to add something about mem_concrete in extension.
   Because if we don't, I don't think we can prove the memory injection preservation.
   
   For now, equality of the fields mem_concrete.


   Then, we need to change magree in Deadcodeproof.v

** DONE [INTPTR][meminj] change unchanged_on
   
   We need to add mem_concrete preservation, for the proof in Separation.v, I think
   
** DONE [INTPTR][meminj] change public memory injection
   
   Separation between public and private memory?
   Private when exclusively owned by the current function.
   In Memory model, v2, they say that unused local variables are "pulled out of memory".
   Everything under memory injection is public.
   The rest is private.
   Look at ec_mem_inject to see how it is dealt with.
   what about integer overflow? and mi_representable?
   in inject, I think we can add every constraint we want on PUBLIC memory.
*** DONE [INTPTR][meminj] No source concrete and target logical in public
    I think it should be in either mem_inj or inject.
    Which one? It depends if we want the property to also hold for memory extension.


    mi_source_concrete
      b1 b2 delta addr
      (INJECT: f b1 = Some(b2, delta))
      (CONCRETE: m1.(mem_concrete)#b1 = Some addr):
      m2.(mem_concrete)#b2 = Some (addr+delta);

      addr+delta to be able to access b1 and b2 with the same indexes. 
*** DONE [INTPTR][meminj][proofs] prove the new injection
**** DONE [INTPTR][meminj][proofs] Memory.v
     the two last proofs require a better version of extends
     extends must preserve the field mem_concrete, I think.
**** DONE [INTPTR][meminj][proofs] Separation.v
     We just need to change the unchanged_on definition to add that mem_concrete is preserved.
     Then the proof will be ok.
**** DONE [INTPTR][meminj][proofs] ValueDomain.v
**** DONE [INTPTR][meminj][proofs] Unusedglobproof.v
     I don't know how to do that.
*** DONE [INTPTR][meminj] Concrete addresses equality?
    The paper says that they must coincide.
    Isn't equality too strong? I'm not sure.

    I added concrete address equality (with an offset)
** DONE [INTPTR][meminj] prove memory injection preserved with capture
** TODO [INTPTR][meminj] No source concrete in private memory
*** DONE [INTPTR][meminj] change inject'

    The blocks that are mapped to None with the mem injection.
    We must say that if a block is mapped to None, then it is logical.
    This should be added in inject'.
    
*** TODO [INTPTR][meminj] proofs
**** DONE [INTPTR][meminj][proofs] Memory.v
**** DONE [INTPTR][meminj][proofs] Separation.v
**** TODO [INTPTR][meminj][proofs] ValueDomain.v
     I think we need to change mmatch
**** DONE [INTPTR][meminj][proofs] Unusedglobproof.v
* DONE [INTPTR] Freeing: on blocks or addresses?
  
  See the issue on Github.
  For now, I added a field mem_valid: block -> bool.
  But I haven't changed the freeing function or anything.
  -> We can free addresses, with permission set to None.
  Then overlapping has to be defined on addresses: 
    foreach address, there is not more than one concrete block in which the address is Freeable.
    
* DONE [INTPTR] Check if there are any cases of alloc with lo!=0
  yes, in cfrontend/Cexec.v
  Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) in
* DONE [INTPTR] Fatal error: out of memory on common/Separation.v
  firstorder auto fails.
  do the proofs in the older version, and see what auto does,
  then inline the proofs in the new version?
  
  info_auto with *.
  info ...
  Show Proof.
  Print thm.
 
