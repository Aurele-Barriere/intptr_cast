* DONE [INTPTR] meeting about the paper (14h)
  SCHEDULED: <2017-05-17 Wed>
* DONE [INTPTR] meeting 11h
  SCHEDULED: <2017-05-18 Thu>
* TODO [INTPTR][memupdate] semantics update on memory
  DEADLINE: <2017-05-29 Mon>
  in [[/home/aurele/intptrcast/CompCert-intptr/common/Memory.v][Memory.v]]
** DONE [INTPTR][memupdate] add p:option Z
   called mem_concrete inside the memory

   Remaining question:
   Should a call of free set the option back to None or leave it unchanged?
   It depends on the semantics we want to give to the casting of a freed pointer.
    -> the current decision is to leave it unchanged
   
** DONE [INTPTR][memupdate][consistency] add consistency

   added as a Definition: mem -> Prop

*** DONE [INTPTR][memupdate][consistency] No overlap

    I've implemented the simple version of overlap (we don't look inside the blocks the free addresses)

    To define this we need the size of each block.
    This has been added inside the memory as a field mem_block_size : block -> Z.

    
    Two questions on the size field:
    
        What should be the initial value of the size? on an empty memory. -> doesn't really matter
    
	When freeing, should we put it back to 0? -> NO

*** DONE [INTPTR][memupdate][consistency] Next block logicals
    
    This says that every block after nextblock is a logical block.
    Because we never want to capture a block that hasn't been allocated.
    This is need to prove memory_consistency, so it has been added here.

*** DONE [INTPTR][memupdate][consistency] First and last address
    
    For now, we only have a property that says that there is no concrete block
    with concrete address 0.
    How to deal with last address? At this point, the memory is infinite. 

    Should it be done in a later pass of CompCert? Or right now because we are dealing with real addresses?
    
*** DONE [INTPTR][memupdate][consistency] contained in memory

    We want to say that no block overflows the memory, i.e
    forall b, address(b)+size(b) < max_memory.
    Here again, we need the size of the memory.

    Both of these properties using the max size make memory_consistency preservation hard to prove.
    
** DONE [INTPTR][memupdate] Proof of memory consistency

   I have proved that empty is a consistent memory.

   And for every operation in {store,storebytes,alloc,free,perm_drop,capture},
   I have proved memory_consistency preservation.

** DONE [INTPTR][memupdate] add realize/capture as a fifth operation

   Capture should now be an operation, just like store,alloc,...
   This has been implemented with a predicate rather than a function,
   Because the address given to a block while capturing is undeterministic.
   
   Questions:

       When trying to capture an already concrete block, is this a capture? -> Yes, this sould be allowed
       Maybe sometimes, we'll have to successives capture of the same pointer.

       One of the hypothesis of the predicate is the memory_consistency preservation. Is that right?

** DONE [INTPTR][memupdate] add properties of capture

   Each operation has a lot of theorems. Some might be useful later.
   What should we prove for the capture ?
   DONE : memory_consistency preservation

   We'll see later.

** DONE [INTPTR][memupdate] add valid pointer
   
   See page 6, section 4 of the paper.

** DONE [INTPTR][memupdate] remove mem_valid
** DONE [INTPTR][memupdate] rewrite valid_pointer
** DONE [INTPTR][memupdate] remove size, remember low and high offsets
   implemented with a field 
   mem_offset_bounds
   block -> Z*Z
** DONE [INTPTR][memupdate] rewrite overlap
** DONE [INTPTR][memupdate] rewrite consistency proofs
   
   Need proofs for alloc
   
   And issue:
   I have zle lo addr, I want to prove lo<=addr.
   However, zle is {x<=y}+{y>x}. -> DONE
   
** DONE [INTPTR][memupdate] rewrite normalize and denormalize

   With the new block representation (p,lo,hi)

** DONE [INTPTR][memupdate] add memory parameter
   I use [if Archi.ptr64 then int64 else int].
   Is it ok?
   It seems that [Archi.ptr64] is set to false, will it be changed when compiling for x64?

   Representing the addresses:
   Either we use the types int and int64, and then for each operation,
   we must prove they are in the right range.
   Issues arise because we often add an address and something else (for instance, low offset bound)

   Or we use type Z, and then we add a memory consistency invariant,
   that says that every concrete address is in the right range.
   But then we must cast the address from Z to int. Is it ok?

** DONE [INTPTR][memupdate] finish consistency proofs
** DONE [INTPTR][memupdate][review] pull request
*** DONE [INTPTR][memupdate][review] put consistency inside of mem'
*** DONE [INTPTR][memupdate][review] do every obligation
*** DONE [INTPTR][memupdate][review] memory size?
    
    changed it to max_address for now
    the issue of real memory size should be addressed later
*** DONE [INTPTR][memupdate][review] no let
*** DONE [INTPTR][memupdate][review] inductive addr_in_concrete_block. inductive consistency
*** DONE [INTPTR][memupdate][review] name hypothesis in weaker_access
*** DONE [INTPTR][memupdate][review] remove comment in empty
*** DONE [INTPTR][memupdate][review] change exists_at_most_one_block
*** DONE [INTPTR][memupdate][review] spaces
*** DONE [INTPTR][memupdate][review] HRANGE instead of HLOW HHIGH
*** DONE [INTPTR][memupdate][review] remove exists_at_most_one_block
*** DONE [INTPTR][memupdate][review] addresses_in_range should rely on hi lo rather than address_in_block
    We'll do it later, if we change our minds regarding the way permissions are given

*** DONE [INTPTR][memupdate][review] rename weaker_access (access_le?)
*** DONE [INTPTR][memupdate][review] concrete_nextblock needs to be changed
*** DONE [INTPTR][memupdate][review] double capture
*** DONE [INTPTR][memupdate][review] return offset in addr_in_concrete_block
*** DONE [INTPTR][memupdate][review] predicate for addr in [p+lo, p+hi[
*** DONE [INTPTR][memupdate][review] rename m_access
*** DONE [INTPTR][memupdate][review] use uniqueness for exists_at_most_one
*** DONE [INTPTR][memupdate][review] change addr_in_block for a pair
*** DONE [INTPTR][memupdate][review] define range
** DONE [INTPTR][memupdate] rewrite with better coq style (no arrows)
   
   omit forall
   name hypothesis
   name goal with << >>
   props in caps
   a.(x)
   exploit

   using Sflib library

** TODO [INTPTR][memupdate] add normalization of pointer (cast2int) and denormalization (cast2ptr)

   see page 6, section 4 of the paper.
   The denormalize is a predicate, not a function.
   Because I can't filter a Map on the Positive numbers.

   Is it ok?

** TODO [INTPTR][memupdate] null pointer
   Add it (page 6).
   Raises undef when storing or loading null pointer.
** DONE [INTPTR][memupdate] use Nonempty instead of Readable
** TODO [INTPTR][memupdate] change memory extension

   This has not been done at all.

** TODO [INTPTR][memupdate] change memory injection

   This has not been done at all.
   I don't think there should be an equality between the source's concrete addresses and 
   the target's concrete addresses.
   
   Because we want the memory of x:=0;y:=1 to inject in the memory of 
   y:=1;x:=0 to allow optimizations, and we have no guarantee on the concrete addresses (no order).

   Concrete source block must be mapped to concrete logical block.
   Separation between public and private memory?

* DONE [INTPTR][memupdate] Freeing: on blocks or addresses?
  
  See the issue on Github.
  For now, I added a field mem_valid: block -> bool.
  But I haven't changed the freeing function or anything.
  -> We can free addresses, with permission set to None.
  Then overlapping has to be defined on addresses: 
    foreach address, there is not more than one concrete block in which the address is Freeable.
    
* DONE [INTPTR] Check if there are any cases of alloc with lo!=0
  yes, in cfrontend/Cexec.v
  Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) in
* TODO [INTPTR] Fatal error: out of memory on common/Separation.v
  firstorder auto fails.
  do the proofs in the older version, and see what auto does,
  then inline the proofs in the new version?
