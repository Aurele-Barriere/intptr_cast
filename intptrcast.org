* DONE [INTPTR] meeting about the paper (14h)
  SCHEDULED: <2017-05-17 Wed>
* DONE [INTPTR] meeting 11h
  SCHEDULED: <2017-05-18 Thu>
* TODO [INTPTR][memupdate] semantics update on memory
  DEADLINE: <2017-05-23 Tue>
  in [[/home/aurele/intptrcast/CompCert-intptr/common/Memory.v][Memory.v]]
** DONE [INTPTR][memupdate] add p:option Z
   called mem_concrete inside the memory

   Remaining question:
   Should a call of free set the option back to None or leave it unchanged?
   It depends on the semantics we want to give to the casting of a freed pointer.
    -> the current decision is to leave it unchanged
   
** DONE [INTPTR][memupdate] add consistency

   added as a Definition: mem -> Prop

*** DONE [INTPTR][memupdate][consistency] No overlap

    I've implemented the simple version of overlap (we don't look inside the blocks the free addresses)

    To define this we need the size of each block.
    This has been added inside the memory as a field mem_block_size : block -> Z.

    
    Two questions on the size field:
    
        What should be the initial value of the size? on an empty memory. -> doesn't really matter
    
	When freeing, should we put it back to 0? -> NO

*** DONE [INTPTR][memupdate][consistency] Next block logicals
    
    This says that every block after nextblock is a logical block.
    Because we never want to capture a block that hasn't been allocated.
    This is need to prove memory_consistency, so it has been added here.

*** DONE [INTPTR][memupdate][consistency] First and last address
    
    For now, we only have a property that says that there is no concrete block
    with concrete address 0.
    How to deal with last address? At this point, the memory is infinite. 

    Should it be done in a later pass of CompCert? Or right now because we are dealing with real addresses?
    
*** DONE [INTPTR][memupdate][consistency] contained in memory

    We want to say that no block overflows the memory, i.e
    forall b, address(b)+size(b) < max_memory.
    Here again, we need the size of the memory.

    Both of these properties using the max size make memory_consistency preservation hard to prove.
    
** DONE [INTPTR][memupdate] Proof of memory consistency

   I have proved that empty is a consistent memory.

   And for every operation in {store,storebytes,alloc,free,perm_drop,capture},
   I have proved memory_consistency preservation.

** DONE [INTPTR][memupdate] add realize/capture as a fifth operation

   Capture should now be an operation, just like store,alloc,...
   This has been implemented with a predicate rather than a function,
   Because the address given to a block while capturing is undeterministic.
   
   Questions:

       When trying to capture an already concrete block, is this a capture? -> Yes, this sould be allowed
       Maybe sometimes, we'll have to successives capture of the same pointer.

       One of the hypothesis of the predicate is the memory_consistency preservation. Is that right?

** TODO [INTPTR][memupdate] add properties of capture

   Each operation has a lot of theorems. Some might be useful later.
   What should we prove for the capture ?
   DONE : memory_consistency preservation

   We'll see later.

** DONE [INTPTR][memupdate] add valid pointer
   
   See page 6, section 4 of the paper.

** DONE [INTPTR][memupdate] remove mem_valid
** DONE [INTPTR][memupdate] rewrite valid_pointer
** DONE [INTPTR][memupdate] remove size, remember low and high offsets
   implemented with a field 
   mem_offset_bounds
   block -> Z*Z
** DONE [INTPTR][memupdate] rewrite overlap
** TODO [INTPTR][memupdate] rewrite consistency proofs
** TODO [INTPTR][memupdate] rewrite normalize and denormalize
   With the new block representation (p,lo,hi)
** DONE [INTPTR][memupdate] add memory parameter
   I use [if Archi.ptr64 then int64 else int].
   Is it ok?
   It seems that [Archi.ptr64] is set to false, will it be changed when compiling for x64?

   Representing the addresses:
   Either we use the types int and int64, and then for each operation,
   we must prove they are in the right range.
   Issues arise because we often add an address and something else (for instance, low offset bound)

   Or we use type Z, and then we add a memory consistency invariant,
   that says that every concrete address is in the right range.
   But then we must cast the address from Z to int. Is it ok?

** DONE [INTPTR][memupdate] finish consistency
** TODO [INTPTR][memupdate] rewrite with better coq style (no arrows)
** DONE [INTPTR][memupdate] add normalization of pointer (cast2int) and denormalization (cast2ptr)

   see page 6, section 4 of the paper.
   The denormalize is a predicate, not a function.
   Because I can't filter a Map on the Positive numbers.

   Is it ok?

** TODO [INTPTR][memupdate] null pointer
   Add it (page 6).
   Raises undef when storing or loading null pointer.
** TODO [INTPTR][memupdate] change memory extension

   This has not been done at all.

** TODO [INTPTR][memupdate] change memory injection

   This has not been done at all.

* DONE [INTPTR][memupdate] Freeing: on blocks or addresses?
  
  See the issue on Github.
  For now, I added a field mem_valid: block -> bool.
  But I haven't changed the freeing function or anything.
  -> We can free addresses, with permission set to None.
  Then overlapping has to be defined on addresses: 
    foreach address, there is not more than one concrete block in which the address is Freeable.
    
* DONE [INTPTR] Check if there are any cases of alloc with lo!=0
  yes, in cfrontend/Cexec.v
  Mem.alloc m (- size_chunk Mptr) (Ptrofs.unsigned sz) in
